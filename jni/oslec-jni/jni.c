/*
Serval Distributed Numbering Architecture (DNA)
Copyright (C) 2010 Paul Gardner-Stephen
 
This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.
 
This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
 
You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
*/

#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>

#include <jni.h>
#include <telephony.h>
#include <echo.h>
#include <android/log.h> 

// TODO if building for a 64bit jvm...
#define JVM_PTR jint

// method signatures as generated by javah -jni

/*
 * Class:     org_servalproject_audio_Oslec
 * Method:    echoCanInit
 * Signature: (II)I
 */
JNIEXPORT jint JNICALL Java_org_servalproject_audio_Oslec_echoCanInit
(JNIEnv *, jclass, jint, jint);

/*
 * Class:     org_servalproject_audio_Oslec
 * Method:    echoCanUpdate
 * Signature: (I[BI[BI[BII)I
 */
JNIEXPORT jint JNICALL Java_org_servalproject_audio_Oslec_echoCanUpdate
(JNIEnv *, jclass, jint, jbyteArray, jint, jbyteArray, jint, jint);

/*
 * Class:     org_servalproject_audio_Oslec
 * Method:    echoCanFree
 * Signature: (I)V
 */
JNIEXPORT void JNICALL Java_org_servalproject_audio_Oslec_echoCanFree
(JNIEnv *, jclass, jint);



int dump(char *name, unsigned char *addr, size_t len)
{
	char buf[100], *p;
	size_t i;
	__android_log_print(ANDROID_LOG_DEBUG, "oslec", "Dump of %s", name);
	for(i = 0; i < len; i += 16) {
		p=buf;
		p+=sprintf(p, "  %04x :", i);
		int j;
		for (j = 0; j < 16 && i + j < len; j++)
			p+=sprintf(p, " %02x", addr[i + j]);
		for (; j < 16; j++){
			strcat(p,"   ");p+=strlen(p);
		}
		strcat(p,"   ");p+=strlen(p);
		for (j = 0; j < 16 && i + j < len; j++)
			p+=sprintf(p, "%c", addr[i+j] >= ' ' && addr[i+j] < 0x7f ? addr[i+j] : '.');
		__android_log_print(ANDROID_LOG_DEBUG, "oslec", "%s", buf);
	}
	
	return 0;
}


JNIEXPORT JVM_PTR JNICALL
Java_org_servalproject_audio_Oslec_echoCanInit(JNIEnv *env, jclass class, jint len, jint adaption_mode) {
	return (JVM_PTR)echo_can_create(len, adaption_mode);
}


// use the samples from the tx buffer to look for echo's in the rx buffer and modify it to remove them
JNIEXPORT jint JNICALL
Java_org_servalproject_audio_Oslec_echoCanUpdate(JNIEnv *env, jclass class, JVM_PTR echo_can_state, 
																	jbyteArray txArray, jint txOffset,
																	jbyteArray rxArray, jint rxOffset,
																	jint len) {
	
	echo_can_state_t *state = (echo_can_state_t*)echo_can_state;
	int16_t *srx = NULL;
	int16_t *stx = NULL;
	jbyte *rx = NULL;
	jbyte *tx = NULL;
	int i, modified=0;
	
	
	if (len<0)
		return -1;
	
	// allow either the rx or tx buffers to be NULL pointers
	// then just pass silence into the echo canceller
	
	if (rxArray){
		jsize rxLen = (*env)->GetArrayLength(env, rxArray);
		if (rxOffset<0 || rxOffset + len > rxLen)
			return -1;
	}
	
	if (txArray){
		jsize txLen = (*env)->GetArrayLength(env, txArray);
		if (txOffset + len > txLen || txOffset<0)
			return -1;
	}
	
	if (rxArray){
		rx = (*env)->GetByteArrayElements(env, rxArray, (jboolean *)NULL);
		srx = (int16_t *)(rx+rxOffset);
	}
	
	if (txArray){
		tx = (*env)->GetByteArrayElements(env, txArray, (jboolean *)NULL);
		stx = (int16_t *)(tx+txOffset);
	}
	
	for (i=0;i<(len/2);i++){
		int16_t x = echo_can_update(state, txArray?stx[i]:0, rxArray?srx[i]:0);
		if (rxArray && srx[i]!=x){
			srx[i] =x;
			modified =1;
		}
	}
	
	if (rxArray)
		(*env)->ReleaseByteArrayElements(env, rxArray, rx, 0);
	if (txArray)
		(*env)->ReleaseByteArrayElements(env, txArray, tx, 0);
	
	return modified;
}

JNIEXPORT void JNICALL
Java_org_servalproject_audio_Oslec_echoCanFree(JNIEnv *env, jclass class, JVM_PTR echo_can_state) {
	echo_can_state_t *state = (echo_can_state_t*)echo_can_state;
	echo_can_free(state);
}

