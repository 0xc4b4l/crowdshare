#!/bin/sh
# vim: sts=2 sw=2 et
#
# Serval Batphone
# Copyright (C) 2011 The Serval Project
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

ME="${0##*/}"
HERE=`dirname "$0"`
DEV=DEVICE
APK=bin/batphone.apk
APK_DEBUG=bin/batphone-debug.apk
AHOME=/data/data/org.servalproject
SERVALD_BIN=$HERE/libs/armeabi/servald
TMP=${SERVAL_TMPDIR:-${TMPDIR:-/tmp}}

# Logic to ensure that all child processes are terminated and temporary files
# cleaned up whenever this script terminates.
pids=
running_pid=
trap 'stat=$?; [ "$running_pid" ] && kill $running_pid 2>/dev/null; [ "$pids" ] && kill $pids 2>/dev/null; rm -rf ${TMP}/$ME-$$-*; exit $stat' 0 1 2 15

usage() {
  echo	  "Usage: ${0##*/} [options] action [args ... ;] [action [args ... ;] ...]"
  echo	  "Options:"
  echo	  "   -n        Dry run; print commands but do not execute"
  echo	  "   -l        List connected devices and exit"
  echo	  "   -s DEV    Perform actions only on DEV (can give more than once)"
  echo	  "   -h, -?    Display this help and exit"
  echo	  "Actions:"
  echo	  "   ps                                  List all serval processes"
  echo	  "   sh|shell [cmd args... ;]            Run shell command (interactive if no cmd)"
  echo	  "   su|sudo cmd [args... ;]             Run shell command as superuser"
  echo	  "   au|app-uninstall                    Uninstall org.servalproject application"
  echo	  "   ai|app-install                      Install $APK"
  echo	  "   aid|app-install-debug               Install $APK_DEBUG"
  echo	  "   ar|app-reinstall                    Reinstall $APK"
  echo	  "   ard|app-reinstall-debug             Reinstall $APK_DEBUG"
  echo	  "   as|app-start                        Start org.servalproject application"
  echo	  "   du|servald-unlock                   Unlock servald binary (chmod a+rwx various files)"
  echo	  "   dl|servald-lock                     Lock servald binary (chmod go-rwx various files)"
  echo	  "   dp|servald-push                     Push servald binary, if no permission then unlock and retry"
  echo	  "   dq|servald-query                    Detect if servald is running (greps ps output)"
  echo	  "   dt|servald-term                     Send SIGTERM to all running servald processes"
  echo	  "   dh|servald-hup                      Send SIGHUP to all running servald processes"
  echo	  "   d9|servald-kill                     Send SIGKILL to all running servald processes"
  echo	  "   ds|servald-start [args... ;]        Run servald in foreground (if not running) with given args"
  echo	  "   servald|servald-invoke [args... ;]  Invoke servald with arguments"
  echo	  "   lc|logcat [args... ;]               Run adb logcat with arguments"
  echo	  "   fp|file-push path dest [;]          Push single file"
  echo	  "   fp|file-push path... dest/ [;]      Push many files to single directory"
}

# The following functions implement actions.  Functions starting with underscore '_' are generally
# not exposed directly to the command line.

_devices() {
  adb devices | awk 'NF == 2 && $2 == "device" {print $1}'
}

shell() {
  run adb -s $DEV shell "$@"
}

shell_sudo() {
  run adb -s $DEV shell echo "$@" \| su
}

serval_processes() {
  echo "+ adb -s $DEV shell ps | grep -i serval"
  if [ $flag_dryrun -le 1 ]; then
    adb -s $DEV shell ps | sed -n -e '1p' -e '/serval/Ip'
  fi
}

app_uninstall() {
  run adb -s $DEV uninstall org.servalproject
}

app_install() {
  run adb -s $DEV install "$1"
}

app_reinstall() {
  run adb -s $DEV install -r "$1"
}

app_start() {
  run adb -s $DEV shell am start -a android.intent.action.MAIN -n org.servalproject/.Main
}

servald_push() {
  if ! _servald_push 2>$TMP/$ME-$$-pusherrs; then
    if grep -q -i 'permission denied' $TMP/$ME-$$-pusherrs; then
      servald_unlock
      _servald_push
      servald_lock
    else
      cat $TMP/$ME-$$-pusherrs >&2
    fi
  fi
}

_servald_push() {
  uid=`_servald_uid`
  if [ -z "$uid" ]; then
    echo "+ servald is not present, cannot push"
  else
    run adb -s $DEV push "$SERVALD_BIN" "$AHOME/bin/servald"
    run adb -s $DEV shell echo chown $uid "$AHOME/bin/servald" '|' su
  fi
}

_servald_chmod() {
  run adb -s $DEV shell "cd $AHOME && echo chmod $1 bin bin/servald | su"
}

servald_unlock() {
  _servald_chmod 777
}

servald_lock() {
  _servald_chmod 700
}

servald_query() {
  servald_pids=`_servald_pids`
  if [ -n "$servald_pids" ] ; then
    echo "+ servald is running, pids" $servald_pids
  else
    echo "+ servald is not running"
  fi
}

servald_kill() {
  servald_pids=`_servald_pids`
  if [ -n "$servald_pids" ] ; then
    local pid
    for pid in $servald_pids; do
      _kill $1 $pid
    done
  else
    echo "+ servald is not running -- not killed"
  fi
}

servald_start() {
  servald_pids=`_servald_pids`
  if [ -n "$servald_pids" ] ; then
    echo "+ servald is already running, pids" $servald_pids "-- not started"
  else
    _servald_start "$@"
  fi
}

servald_invoke() {
  _servald_invoke "$@"
}

_servald_invoke() {
  uid=`_servald_uid`
  if [ -z "$uid" ]; then
    echo "+ missing $AHOME/bin/servald"
  else
    run adb -s $DEV shell cd $AHOME '&&' echo echo "$AHOME/bin/servald" "$@" '\|' su $uid '|' su
  fi
}

_servald_start() {
  _servald_invoke start "$@"
}

_servald_uid() {
  if [ $flag_dryrun -le 1 ]; then
    adb -s $DEV shell echo ls -l "$AHOME/bin/servald" "'2>/dev/null'" '|' su | awk '{ print $2 }'
  fi
}

_servald_pids() {
  if [ $flag_dryrun -le 1 ]; then
    adb -s $DEV shell ps | tr -d '\r' | awk '$9 == "'"$AHOME/bin/servald"'" { print $2 }'
  fi
}

_kill() {
  run adb -s $DEV shell echo kill $1 $2 \| su
}

logcat() {
  run adb -s $DEV logcat "$@"
}

file_push() {
  local dstarg
  eval dstarg="\$$#"
  local i=1
  local src
  local dst
  while [ $i -lt $# ]; do
    eval src=\"\$$i\"
    dst="$dstarg"
    case "$dstarg" in
    */) dst="$dstarg${src##*/}";;
    esac
    run adb -s $DEV push "$src" "$dst"
    i=$(($i + 1))
  done
}

# Add shell quotation to the given arguments, so that when expanded using 'eval', the exact same
# argument results.  This makes our argument handling fully immune to spaces and shell
# metacharacters.
shellarg() {
  local arg
  local sep=
  for arg; do
    /bin/echo -n "$sep"
    case `/bin/echo "$arg" | sed -e 's/[A-Za-z_0-9.,+\/-]//g'` in
    '') /bin/echo -n "$arg";;
    *) /bin/echo -n "'"; /bin/echo -n "$arg" | sed -e "s/'/'\\\\''/g"; /bin/echo -n "'";;
    esac
    sep=' '
  done
  echo
}

# The function we use to invoke commands.  This implements the effect of the -n (dry run) option.
run() {
  echo -n "+ "; shellarg "$@"
  if [ $flag_dryrun -eq 0 ]; then
    "$@" &
    running_pid=$!
    wait $!
    running_pid=
  fi
}

# Parse command-line options (leading arguments starting with '-').
flag_dryrun=0
flag_list=false
devices=
device_opts=
while getopts "Sndls:h?" opt
do
  case $opt in
  n) flag_dryrun=$(($flag_dryrun+1));;
  l) flag_list=true;;
  s) devices="$devices $OPTARG"; device_opts="$device_opts -s '$OPTARG'";;
  h|\?) usage; exit 0;;
  *) echo "${0##*/}: unsupported option '$opt'" >&2; exit 1;;
  esac
done
shift $(($OPTIND - 1))

# If the -l option was given, then print a list of connected devices with their
# DIDs (phone numbers), and exit.
if $flag_list; then
  for DEV in `_devices`
  do
    echo -n "$DEV"
    for DID in $(_servald_invoke keyring list '2>/dev/null' | sed -n -e '/:./s/^.*:\([0-9]\+\).*$/\1/p')
    do
      echo -n " ($DID)"
    done
    echo
  done
  exit 0
fi

# If the script was invoked with no arguments, then print a helpful usage message.
if [ $# -eq 0 ]; then
  usage
  exit 0
fi

# If we haven't already, get a list of all connected devices.
if [ -z "$devices" ]; then
  devices=`_devices`
fi

# Parse remaining command-line arguments into a string of shell commands that can be executed using
# 'eval'.  Be very careful to preserve all arguments intact, so that spaces, quotes, metacharacters
# etc. get passed verbatim to the adb command.
actions=true
interactive=false
shiftargs() {
  actions="$actions ; $1"
  shift
  NARGS=0
  while [ $# -ne 0 -a "$1" != ';' ]
  do
    actions="$actions `shellarg \"$1\"`"
    NARGS=$(($NARGS+1))
    eval ARG$NARGS=\"\$1\"
    LASTARG="$1"
    shift
  done
}
while [ $# -ne 0 ]
do
  action="$1"
  shift
  case $action in
  \; ) ;;
  sh | shell )		      shiftargs 'shell' "$@"; shift $NARGS; [ $NARGS -eq 0 ] && interactive=true;;
  su | sudo )		      shiftargs 'shell_sudo' "$@"; shift $NARGS;;
  ps )			      actions="$actions ; serval_processes";;
  au | app-uninstall )	      actions="$actions ; app_uninstall";;
  ai | app-install )	      actions="$actions ; app_install '$APK'";;
  aid | app-install-debug )   actions="$actions ; app_install '$APK_DEBUG'";;
  ar | app-reinstall )	      actions="$actions ; app_reinstall '$APK'";;
  ard | app-reinstall-debug ) actions="$actions ; app_reinstall '$APK_DEBUG'";;
  as | app-start )	      actions="$actions ; app_start";;
  du | servald-unlock )	      actions="$actions ; servald_unlock";;
  dl | servald-lock )	      actions="$actions ; servald_lock";;
  dp | servald-push )	      actions="$actions ; servald_push";;
  dq | servald-query )	      actions="$actions ; servald_query";;
  dh | servald-hup )	      actions="$actions ; servald_kill -1";;
  dt | servald-term )	      actions="$actions ; servald_kill -15";;
  d9 | servald-kill )	      actions="$actions ; servald_kill -9";;
  di | servald-invoke )       shiftargs 'servald_invoke' "$@"; shift $NARGS;;
  ds | servald-start )	      shiftargs 'servald_start' "$@"; shift $NARGS;;
  lc | logcat )	              shiftargs 'logcat' "$@"; shift $NARGS;;
  fp | file-push )
    shiftargs 'file_push' "$@"
    shift $NARGS
    if [ $NARGS -lt 2 ]; then
      echo "Action '$action' missing argument -- see ${0##*/} -h for help." >&2
      exit 1
    fi
    if [ $NARGS -gt 2 ]; then
      case "$LASTARG" in
      */) ;;
      *)
        echo "Action '$action' last argument must be a directory and end in '/' -- see ${0##*/} -h for help." >&2
        exit 1
        ;;
      esac
    fi
    ;;
  *)
    echo "Unsupported action '$action' -- see ${0##*/} -h for help." >&2
    exit 1
    ;;
  esac
done

# Execute all the actions, and collate their outputs on the terminal in the best fashion available.
if [ $flag_dryrun -ne 0 ]; then
  for DEV in $devices
  do
    eval "$actions"
  done
else
  if $interactive; then
    set -- $devices
    if [ $# -gt 1 ]; then
      echo "$ME: interactive command only works on one device at a time" >&2
      echo "Use the -s DEVICE option to select one device; see $ME -h for more information." >&2
      exit 1
    fi
    DEV="$1"
    echo "+ START"
    eval "$actions"
    echo "+ DONE"
  else
    mkdir $TMP/$ME-$$-logs || exit $?
    tailargs=
    for DEV in $devices
    do
      echo "+ START" >$TMP/$ME-$$-logs/$DEV
      tailargs="$tailargs -f $TMP/$ME-$$-logs/$DEV"
      (
        trap 'stat=$?; [ "$running_pid" ] && kill $running_pid; exit $stat' 0 1 2 15
        eval "$actions"
        echo "+ DONE"
      ) >>$TMP/$ME-$$-logs/$DEV 2>&1 &
      pids="$pids $!"
    done
    case `multitail -V 2>&1` in
    *'--*- multitail '*)
      multitail $tailargs
      ;;
    *)
      tail $tailargs
      ;;
    esac
  fi
fi
